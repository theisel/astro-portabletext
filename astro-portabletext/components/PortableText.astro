---
import {
  isPortableTextBlock,
  isPortableTextListItemBlock,
  isPortableTextToolkitList,
  isPortableTextToolkitSpan,
  isPortableTextToolkitTextNode,
  nestLists,
  buildMarksTree,
  LIST_NEST_MODE_HTML,
} from "@portabletext/toolkit";

import type { PortableTextBlock } from "@portabletext/types";

import type {
  MissingComponentHandler,
  PortableTextComponents,
  PortableTextProps,
  Props as ComponentProps,
  TypedObject,
} from "../lib/types";

import {
  isComponent,
  mergeComponents,
  type Component,
  type NodeType,
} from "../lib/internal";

import { getWarningMessage, printWarning } from "../lib/warnings";
import { key as contextRef, type Context } from "../lib/context";

import Block from "./Block.astro";
import HardBreak from "./HardBreak.astro";
import List from "./List.astro";
import ListItem from "./ListItem.astro";
import Mark from "./Mark.astro";
import Text from "./Text.astro";
import UnknownBlock from "./UnknownBlock.astro";
import UnknownList from "./UnknownList.astro";
import UnknownListItem from "./UnknownListItem.astro";
import UnknownMark from "./UnknownMark.astro";
import UnknownType from "./UnknownType.astro";

export type Props = PortableTextProps;

const {
  value,
  components: componentOverrides = {},
  listNestingMode = LIST_NEST_MODE_HTML,
  onMissingComponent = true,
} = Astro.props;

const components = mergeComponents(
  {
    type: {},
    unknownType: UnknownType,
    block: {
      h1: Block,
      h2: Block,
      h3: Block,
      h4: Block,
      h5: Block,
      h6: Block,
      blockquote: Block,
      normal: Block,
    },
    unknownBlock: UnknownBlock,
    list: {
      bullet: List,
      number: List,
      menu: List,
    },
    unknownList: UnknownList,
    listItem: {
      bullet: ListItem,
      number: ListItem,
      menu: ListItem,
    },
    unknownListItem: UnknownListItem,
    mark: {
      code: Mark,
      em: Mark,
      link: Mark,
      "strike-through": Mark,
      strong: Mark,
      underline: Mark,
    },
    unknownMark: UnknownMark,
    text: Text,
    hardBreak: HardBreak,
  },
  componentOverrides
) as PortableTextComponents;

const noop = () => {};

const missingComponentHandler = ((
  handler: unknown
): MissingComponentHandler => {
  if (typeof handler === "function") {
    return handler as MissingComponentHandler;
  }
  return !handler ? noop : printWarning;
})(onMissingComponent);

const serializeNode =
  (isInline: boolean) =>
  (node: TypedObject, index: number = 0) =>
    asComponentProps(node, index, isInline);

const serializeChildren = (
  node: TypedObject & { children: TypedObject[] },
  isInline: boolean
) => node.children.map(serializeNode(isInline));

const serializeMarksTree = (node: PortableTextBlock) =>
  buildMarksTree(node).map(serializeNode(true));

const asComponentProps = (
  node: TypedObject,
  index: number,
  isInline: boolean
): ComponentProps<typeof node> => ({
  node,
  index,
  isInline,
});

const provideComponent = (
  nodeType: NodeType,
  type: string,
  fallbackComponent: Component
): Component => {
  const component: Component | undefined = ((component) => {
    return component[type as keyof typeof component] || component;
  })(components[nodeType]);

  if (isComponent(component)) {
    return component;
  }

  missingComponentHandler(getWarningMessage(nodeType, type), {
    nodeType,
    type,
  });

  return fallbackComponent;
};

const prepareForRender = (
  props: ComponentProps<TypedObject>
):
  | [Component | string, ComponentProps<TypedObject>[]]
  | [Component | string] => {
  const { node } = props;

  if (isPortableTextToolkitList(node)) {
    return [
      provideComponent(
        "list",
        node.listItem,
        components.unknownList ?? UnknownList
      ),
      serializeChildren(node, false),
    ];
  }

  if (isPortableTextListItemBlock(node)) {
    return [
      provideComponent(
        "listItem",
        node.listItem,
        components.unknownListItem ?? UnknownListItem
      ),
      serializeMarksTree(node).map((children) => {
        if (node.style !== "normal") {
          const { listItem, ...blockNode } = node;
          children = serializeNode(false)(blockNode, 0);
        }
        return children;
      }),
    ];
  }

  if (isPortableTextToolkitSpan(node)) {
    return [
      provideComponent(
        "mark",
        node.markType,
        components.unknownMark ?? UnknownMark
      ),
      serializeChildren(node, true),
    ];
  }

  if (isPortableTextBlock(node)) {
    return [
      provideComponent(
        "block",
        (node.style ??= "normal") /* Make sure style has been set */,
        components.unknownBlock ?? UnknownBlock
      ),
      serializeMarksTree(node),
    ];
  }

  if (isPortableTextToolkitTextNode(node)) {
    return [
      "\n" === node.text
        ? isComponent(components.hardBreak)
          ? components.hardBreak
          : HardBreak
        : isComponent(components.text)
          ? components.text
          : Text,
    ];
  }

  return [
    provideComponent("type", node._type, components.unknownType ?? UnknownType),
  ];
};

(globalThis as any)[contextRef] = (node: TypedObject): Context => {
  return {
    getDefaultComponent: provideDefaultComponent.bind(null, node),
    getUnknownComponent: provideUnknownComponent.bind(null, node),
  };
};

// Returns the `default` component related to the passed in node
const provideDefaultComponent = (node: TypedObject) => {
  if (isPortableTextToolkitList(node)) return List;
  if (isPortableTextListItemBlock(node)) return ListItem;
  if (isPortableTextToolkitSpan(node)) return Mark;
  if (isPortableTextBlock(node)) return Block;

  if (isPortableTextToolkitTextNode(node)) {
    return "\n" === node.text ? HardBreak : Text;
  }

  return UnknownType;
};

// Returns the `unknown` component related to the passed in node
const provideUnknownComponent = (node: TypedObject) => {
  if (isPortableTextToolkitList(node)) {
    return components.unknownList ?? UnknownList;
  }

  if (isPortableTextListItemBlock(node)) {
    return components.unknownListItem ?? UnknownListItem;
  }

  if (isPortableTextToolkitSpan(node)) {
    return components.unknownMark ?? UnknownMark;
  }

  if (isPortableTextBlock(node)) {
    return components.unknownBlock ?? UnknownBlock;
  }

  if (!isPortableTextToolkitTextNode(node)) {
    return components.unknownType ?? UnknownType;
  }

  throw new Error(
    `[PortableText getUnknownComponent] Unable to provide component with node type ${node._type}`
  );
};

// Make sure we have an array of blocks
const blocks = Array.isArray(value) ? value : [value];

// Using a generator to avoid creating a new array
function* renderBlocks() {
  let index = 0;

  for (const it of nestLists(blocks, listNestingMode)) {
    yield asComponentProps(it, index++, false);
  }
}
---

{
  [...renderBlocks()].map(function render(props) {
    const [Cmp, children = []] = prepareForRender(props);

    return !isComponent(Cmp) ? (
      <Fragment set:text={Cmp} />
    ) : (
      <Cmp {...props}>{children.map(render)}</Cmp>
    );
  })
}
